#include "main.h"
#if defined(MJ828_)	// if this particular device is active

#include "mj828\mj828.h"
#include "mj828\mj828_led.c"	// concrete device-specific LED functions
#include "mj828\mj828_button.c"	// concrete device-specific button functions

typedef struct	// mj828_t actual
{
	mj828_t public;  // public struct
} __mj828_t;

static __mj828_t __Device __attribute__ ((section (".data")));	// preallocate __Device object in .data

void _event_execution_function_mj828(uint8_t val)
{
	switch(val)
		// based on array value at position #foo of array e.g. FooButtonCaseTable[]
		{
		case 0x01:	// error button press
			// TODO - implement device function on button error press
			EventHandler->UnSetEvent(val);
			break;

		case 0x02:	//
			Device->led->Shine(Red);

			if(Device->button->button[Right].Toggle)
				{
					MsgHandler->SendMessage((CMND_DEVICE | DEV_LIGHT | FRONT_LIGHT_HIGH), 0x20, 2);
				}
			else
				{
					MsgHandler->SendMessage((CMND_DEVICE | DEV_LIGHT | FRONT_LIGHT_HIGH), 0x00, 2);
				}
			EventHandler->UnSetEvent(val);
			break;

		case 0x04:	//
			if(Device->button->button[Left].Momentary)
				{
					// FIXME - on button hold, multiple events are triggered and flapping occurs
					Device->led->Shine(Blue);
					MsgHandler->SendMessage((CMND_DEVICE | DEV_LIGHT | FRONT_LIGHT_HIGH), 0xF8, 2);

				}
			else
				{
					Device->led->Shine(Blue);
					MsgHandler->SendMessage((CMND_DEVICE | DEV_LIGHT | FRONT_LIGHT_HIGH), 0x00, 2);

					EventHandler->UnSetEvent(val);
				}
			break;

			//case 0x08:													//
			//// next case
			//EventHandler->UnSetEvent(val);
			//break;

			//case 0x16:
			//// next case
			//EventHandler->UnSetEvent(val);
			//break;

		default:	// no value passed
			EventHandler->UnSetEvent(val);	// do nothing
			break;
		}
}

// toggles a bit in the LED flags variable; charlieplexer in tun makes it shine
void _PopulatedBusOperationMJ828(message_handler_t *const in_msg)
{
	volatile can_msg_t *msg = in_msg->ReceiveMessage();  // CAN message object

	// FIXME - implement proper command nibble parsing; this here is buggy as hell (parsing for set bits is shitty at best)
	if((msg->COMMAND& MASK_COMMAND) == CMND_DASHBOARD )  // dashboard command
		{
			__Device.public.led->Shine(((msg->COMMAND & 0x0E) >> 1));  // flag LED at appropriate index as whatever the command says

			return;
		}
}

// GPIO init - device specific, as generated via ioc file
static inline void _GPIOInit(void)
{
// TODO - implement mj828 gpio init
}

// Timer2 init, as generated by ioc file
static inline void _Timer2Init(void)
{
// TODO - implement mj828 charlieplexing timer
}

void mj828_ctor()
{
	// only SIDH is supplied since with the addressing scheme SIDL is always 0
	__Device.public.mj8x8 = mj8x8_ctor((PRIORITY_LOW | UNICAST | SENDER_DEV_CLASS_LU | RCPT_DEV_CLASS_BLANK | SENDER_DEV_D));  // call base class constructor & initialize own SID

	_Timer2Init();	// initialize Timer2 - PWM for charlieplexing
	_GPIOInit();	// initialize device-specific GPIOs

	__Device.public.led = _virtual_led_ctorMJ828();  // call virtual constructor & tie in object addresses
	__Device.public.button = _virtual_button_ctorMJ828();  // call virtual constructor & tie in object addresses

	__Device.public.mj8x8->PopulatedBusOperation = &_PopulatedBusOperationMJ828;	// implements device-specific operation depending on bus activity

	EventHandler->fpointer = &_event_execution_function_mj828;	// implements event hander for this device

	// FIXME - if below flag is 0, it doesn't work properly: at least one LED has to be on for the thing to work
	// also: if any other than Green is on, it doesn't shine properly

	// interrupt init
	// TODO - implement mj828 interrupt init

	__Device.public.led->Shine(GREEN);	// crude power indicator
}

// device-specific interrupt handlers
// pushbutton EXTI0 interrupt handler
void EXTI0_1_IRQHandler(void)  // TODO - specify exact EXTI handler
{
	//HAL_GPIO_EXTI_IRQHandler(Switch_Pin);
}

// pushbutton ISR
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	/* original code:
	 // code to be executed every 25ms
	 sleep_disable();	// wakey wakey

	 Device->button->deBounce();  // call the debouncer

	 sleep_enable();  // back to sleep
	 */

	// TODO - implement mj828 pushbutton ISR
	//HAL_GPIO_TogglePin(GreenLED_GPIO_Port, GreenLED_Pin);
}

// PRT - port to mj828 timer1 - some channel
// TODO - implement ISR for timer0 - 16.25ms - charlieplexing timer
ISR2( TIMER0_COMPA_vect)	// timer/counter0 - 16.25ms - charlieplexed blinking
{
	Device->led->Handler();  // handles LEDs according to CAN message (of type CMND_UTIL_LED)
}

// device-specific interrupt handlers
// TODO - write interrupt code
// device-specific interrupt handlers

// all devices have the object name "Device", hence the preprocessor macro
mj828_t *const Device = &__Device.public;  // set pointer to MsgHandler public part

#endif // MJ828_
